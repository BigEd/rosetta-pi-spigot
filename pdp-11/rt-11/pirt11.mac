;for macro-11 assembler
;it calculates pi-number using the next C-algorithm
;https://crypto.stanford.edu/pbc/notes/pi/code.html

;#include <stdio.h>
;#define N 2800
;main() {
;   long r[N + 1], i, k, b, c;
;   c = 0;
;   for (i = 0; i < N; i++)
;      r[i] = 2000;
;   for (k = N; k > 0; k -= 14) {
;      d = 0;
;      i = k;
;      for(;;) {
;         d += r[i]*10000;
;         b = i*2 - 1;
;         r[i] = d%b;
;         d /= b;
;         i--;
;         if (i == 0) break;
;         d *= i;
;      }
;      printf("%.4d", (int)(c + d/10000));
;      c = d%10000;
;   }
;}

;the time of the calculation is quadratic, so if T is time to calculate N digits
;then 4*T is required to calculate 2*N digits

      .radix 10

EIS = 0   ;hardware multiplication and division, 0 - no

      .MCall .exit, .print, .gtim, .ttyin, .ttyout, .ttinr, .settop, .gval
      $JSW =: ^O44
      TTSPC$ =: ^O10000
      CONFIG = ^O300

MAXD = 7792  ;limited by the division impementation

;N = 10500   ;3000 digits
;N = 3500   ;1000 digits
N = 350   ;100 digits
;N = 2800  ;800 digits

kv = kvs + 2

.macro div0 ?l0 ?l1
     asl r2
     rol r3
     bcs l1            ;for r1 > $7fff

     cmp r3,r1
     bcs l0

l1:  sub r1,r3
     inc r2
l0:
     .endm

.macro div32x16 ?div32 ?div32b ?div32n ?div32x ?exit ?l1 ?l1x ?l2 ?l3 ?l4
    ;R4:R2 = R3:R2/R1, R3 = R3:R2%R1, used: R0, R1 not changed
.if ne EIS
     ;tst r1
     bpl l3           ;R3 < 0x4000

     ;clc
     mov r1,r0
     ror r1
     mov r3,r4
     asl r3
     inc r3    ;?
     cmp r3,r1
     bcc div32n

     mov r2,r3
     mov r4,r2
     div r1,r2
     clr r4
     ror r2
     bcc l1

     add r1,r3
l1:  mov r0,r1
     sub r2,r3
     bcc exit

     dec r2
     add r0,r3
     br exit

div32n:
     mov r2,r3
     mov r4,r2
     clr r4
     ror r2
     ror r3
     rol r4   ;save CF
     div r1,r2
     asl r2
     asl r3
     add r4,r3
     cmp r3,r1
     bcs l2

     inc r2
     sub r1,r3
l2:  clc
     ror r2
     bcc l1x

     add r1,r3
l1x: sub r2,r3
     bcc l4

     dec r2
     add r0,r3
l4:  mov r0,r1
     clr r4
     br exit

div32b:
     mov r2,r0
     clr r2
     div r1,r2
     mov r2,-(sp)
     mov r0,r2

     mov r3,r4
     asl r3
     inc r3     ;?
     cmp r3,r1
     bcc div32x

     mov r2,r3
     mov r4,r2
     div r1,r2
     mov (sp)+,r4
     br exit

div32x:
     clr r0
     ror r4
     ror r2
     rol r0   ;save CF
     mov r2,r3
     mov r4,r2
     div r1,r2
     asl r2
     asl r3
     add r0,r3
     mov (sp)+,r4
     cmp r3,r1
     bcs exit

     inc r2
     sub r1,r3
     br exit

l3:  cmp r3,r1
     bcc div32b

     mov r3,r4
     asl r3
     inc r3     ;?
     cmp r3,r1
     bcc div32

     mov r2,r3
     mov r4,r2
     div r1,r2
     clr r4
     br exit

div32:
     clr r0
     ror r4
     ror r2
     rol r0   ;save CF
     mov r2,r3
     mov r4,r2
     div r1,r2
     asl r2
     asl r3
     add r0,r3
     clr r4
     cmp r3,r1
     bcs exit

     inc r2
     sub r1,r3

.iff
     cmp r3,r1
     bcc div32

     .rept 16
     div0
     .endm
     clr r4
     jmp @#exit

OPT = 2         ;R3 to 0x3fff
div32:
     mov r2,r0

     .rept OPT
     asl r3
     .endm

     mov r3,r2
     clr r3

     .rept 16-OPT
     div0
     .endm

     mov r2,r4
     mov r0,r2

     .rept 16
     div0
     .endm
.endc
exit:
     .endm


START:
         bis #TTSPC$,@#$JSW
         .settop #-2
         sub #ra-2,r0
         mov r0,r2
         clr r3
         mov #7,r1
         call @#div32x16s
         bic #3,r2
         cmp #MAXD,r2
         bcc 205$

         mov #MAXD,r2
205$:    mov r2,@#maxnum
         .print #msg1
         ;mov @#maxnum,r2
         call PR0000
         .print #msg2
         call @#getnum
         .print #eol

         mov r2,r4
         add #3,r4
         bic #3,r4
         cmp r2,r4
         beq 7$

         mov r4,r2
         call @#PR0000
         .print #msg3

7$:      asr r4
         mov r4,r0
         asl r0
         add r0,r4
         asl r0
         add r0,r4   ;r4 <- r4/2*7
         mov r4,@#kv
         inc r4
         mov r4,@#100$+2
         tst -(sp)       ;create the location for high(d)

         .gtim #area,#time
100$:    mov #N+1,r0   ;fill r-array
         mov #2000,r1
         mov #ra,r2
1$:      mov r1,(r2)+
         sob r0,1$

         clr @#cv
mloop:   clr r5       ;d <- 0
         clr @sp

kvs:     mov #0,r1
         asl r1       ;i <- 2k
ivs:

.if eq EIS
         mov ra(r1),r0     ;r[i]
         clr r4         ;r[i]*10000
         ror r0         ;check the previous CF!
         ror r4
         asr r0
         ror r4
         asr r0
         ror r4
         mov r4,r2
         mov r0,r3
         asr r0
         ror r4
         asr r0
         ror r4
         asr r0
         ror r4
         add r4,r2
         adc r3
         add r0,r3
         asr r0
         ror r4
         add r4,r2
         adc r3
         add r0,r3
         asr r0
         ror r4
         add r4,r2
         adc r3
         add r0,r3
         asr r0
         ror r4
         asr r0
         ror r4
         asr r0
         ror r4
         asr r0
         ror r4
         add r4,r2
         adc r3
         add r0,r3

         add r5,r2
         mov r2,r5
.iff
         mov #10000,r2
         mul ra(r1),r2
         bpl 202$

         add #10000,r2
202$:    add r3,r5
         mov r2,r3
         mov r5,r2
.endc
         adc r3
         add @sp,r3
         mov r3,@sp

         dec r1          ;b <- 2*i-1
         div32x16
         mov r3,ra+1(r1)      ;r[i] <- d%b
         dec r1        ;i <- i - 1
         beq 4$

         add r3,r2       ;d <- d/b*i
         adc r4
         mov @sp,r3
         sub r2,r5
         sbc r3
         sub r4,r3
         ror r3
         ror r5
         mov r3,@sp
         jmp @#ivs

4$:      mov r4,r3
         mov #10000,r1
         call @#div32x16s
         add @#cv,r2  ;c + d/10000
         mov r3,@#cv     ;c <- d%10000
         call @#PR0000
         sub #14,@#kv      ;k <- k - 14
         beq 5$
         jmp @#mloop

5$:      mov #time2,r1
         .gtim #area,r1
         mov #32,r0
         .ttyout
         sub @#time+2,@#time2+2
         sbc @#time2
         sub @#time,@#time2

         mov @#time2,r3
         mov @#time2+2,r2
         asl r2
         rol r3
         .gval #area,#CONFIG
         bit #32,r0    ;50 or 60 Hz?
         bne 206$

         asl r2     ;*5
         rol r3
         add @#time2+2,r2
         adc r3
         add @#time2,r3
         mov #3,r1
         call @#div32x16s
         asr r3
         add r3,r2
         mov r1,r3
         adc r3
206$:    mov r3,r0
         mov r2,r1
         call @#printsec   ;prints r0:r1
         tst (sp)+       ;clear the location for high(d)
         .ttinr

         bic #TTSPC$,@#$JSW
         .exit

div32x16s: ;R1:R2 = R3:R2/R1, R3 = R3:R2%R1, used: R0,R4
           ;compact form - 64 bytes
     cmp r3,r1
     bcc 32$

     call @#3$
     clr r1
     return

32$: mov r2,r0
     mov r3,r2
     clr r3
     call @#3$
     mov r2,r4
     mov r0,r2
     call @#3$
     mov r4,r1
     return

3$:  call @#.+4
     call @#.+4
     call @#.+4
     call @#.+4
     asl r2
     rol r3
     bcs 22$    ;for R1>$7fff

     cmp r3,r1
     bcs 20$

22$: sub r1,r3
     inc r2
20$:  return

PRALL:    ;prints r2, used: r0,r2,r3
        mov #10000,r3
	CALL @#PRZ
PR0000:
        mov #1000,r3
	CALL @#PRZ
        mov #100,r3
	CALL @#PRZ
        mov #10,r3
	CALL @#PRZ
	mov r2,r0
PR:	add #48,r0
   	.ttyout
        return

PRZ:	mov #65535,r0
4$:	inc r0
	cmp r2,r3
	bcs PR

	sub r3,r2
	br 4$

printsec:  ;prints R0:R1/100
        mov r1,r2
        mov r0,r1
        clr r4
        mov #1,r5 
        mov #34464,r3  ;100000-65536
        call @#20$
        clr r5 
        mov #10000,r3
        call @#20$
        mov #1000,r3
        call @#20$
        inc r4
        mov #100,r3
        call @#20$
        movb #'.,r0
        .ttyout
        mov #10,r3
        call @#20$
        mov r2,r0
2$:     add #48,r0
        .ttyout
        inc r4
5$:     return

7$:     tst r4
        bne 2$

        tst r0
        beq 5$

        inc r4
        br 2$

20$:    mov #65535,r0
4$:	inc r0
        cmp r1,r5
        bcs 7$
        bne 8$

	cmp r2,r3
	bcs 7$

8$:     sub r3,r2
        sbc r1
        sub r5,r1
	br 4$

cv: .word 0
time: .word 0,0   ;high, low!

    .even
ra:
time2: .word 0,0
msg1: .ascii "number pi"
      ;.byte 160 ;Greek pi
      .ascii " calculator v3" <13> <10>
      .ascii "number of digits (up to " <128>
msg2: .ascii ")? " <128>
msg3: .ascii " digits will be printed"
eol: .byte 0
delstr: .byte 8,32,8,128
maxnum: .word 0
area: .word 0,0

getnum: clr r1    ;length
        clr r2    ;number
20$:     .ttyin
        cmp #13,r0
        beq 5$

        cmp #127,r0   ;backspace
        beq 1$

        cmp #47,r0
        bcc 20$

        cmp #48+9,r0
        bcs 20$

        cmp #4,r1
        beq 20$

        mov r2,-(sp)
        .ttyout
        inc r1
        sub #48,r0
        mov r2,r3
        asl r3
        asl r3
        add r3,r2
        asl r2
        add r0,r2
        br 20$

1$:     tst r1
        beq 20$

        dec r1
        .print #delstr
        mov (sp)+,r2
        br 20$

5$:     tst r1
        beq 20$

        cmp @#maxnum,r2
        bcs 20$

        mov r1,r3
8$:     mov (sp)+,r0
        sob r3,8$
        return

.End	START

